use crate::Params;
use libp2p::{
    core::{transport::PortUse, Endpoint, Multiaddr},
    identity::PublicKey,
    kad::{
        store::{MemoryStore, MemoryStoreConfig},
        Behaviour as Kademlia, Config as KademliaConfig, Event as KademliaEvent, QueryId,
    },
    mdns::{self, tokio::Behaviour as TokioMdns},
    swarm::{
        behaviour::{
            toggle::{Toggle, ToggleConnectionHandler},
            ConnectionClosed, ConnectionEstablished, FromSwarm,
        },
        ConnectionDenied, ConnectionId, NetworkBehaviour, THandler, THandlerInEvent,
        THandlerOutEvent, ToSwarm,
    },
    PeerId,
};
use std::collections::HashMap;
use std::{
    collections::{HashSet, VecDeque},
    task::{Context, Poll},
};
use tracing::{debug, error, trace, warn};

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryOut {
    /// Event that notifies that we connected to the node with the given peer id.
    Connected(PeerId),

    /// Event that notifies that we disconnected with the node with the given peer id.
    Disconnected(PeerId),
}

/// Implementation of `NetworkBehaviour` that discovers the nodes on the network.
pub struct DiscoveryBehaviour {
    /// User-defined list of nodes and their addresses. Typically includes bootstrap nodes and
    /// reserved nodes.
    permanent_addresses: Vec<(PeerId, Multiaddr)>,
    /// Same as `permanent_addresses`, except that addresses that fail to reach a peer are
    /// removed.
    // ephemeral_addresses: HashMap<PeerId, Vec<Multiaddr>>,
    /// Kademlia discovery.
    kademlia: Toggle<Kademlia<MemoryStore>>,
    /// Discovers nodes on the local network.
    mdns: Toggle<TokioMdns>,
    /// Events to return in priority when polled.
    pending_events: VecDeque<DiscoveryOut>,
    /// Number of nodes we're currently connected to.
    num_connections: u64,
    /// Keeps hash set of peers connected.
    peers: HashSet<PeerId>,
    /// Keeps hash map of peers and their multiaddresses
    peer_addresses: HashMap<PeerId, Vec<Multiaddr>>,
}

impl DiscoveryBehaviour {
    pub fn new(local_public_key: PublicKey, params: Params) -> Self {
        let local_peer_id = local_public_key.to_peer_id();
        let mut peers = HashSet::new();
        let peer_addresses = HashMap::new();
        let permanent_addresses: Vec<_> = params
            .rooms
            .iter()
            .flat_map(|ra| ra.boot_nodes.clone())
            .map(|mwp| (mwp.peer_id, mwp.multiaddr))
            .collect();

        let kademlia_opt = {
            if params.kademlia {
                // Create a protocol name for Kademlia
                let protocol = libp2p::swarm::StreamProtocol::new("/ipfs/kad/1.0.0");
                let kad_config = KademliaConfig::new(protocol);
                let store = MemoryStore::with_config(local_peer_id, MemoryStoreConfig::default());
                let mut kademlia = Kademlia::with_config(local_peer_id, store, kad_config);
                kademlia.set_mode(Some(libp2p::kad::Mode::Server));
                for (peer_id, addr) in permanent_addresses.iter() {
                    kademlia.add_address(peer_id, addr.clone());
                    peers.insert(*peer_id);
                }
                if let Err(e) = kademlia.bootstrap() {
                    warn!("Kademlia bootstrap failed: {}", e);
                }
                Some(kademlia)
            } else {
                None
            }
        };

        let mdns_opt = if params.mdns {
            match TokioMdns::new(libp2p::mdns::Config::default(), local_peer_id) {
                Ok(mdns) => Some(mdns),
                Err(err) => {
                    warn!("Failed to initialize mDNS: {:?}", err);
                    None
                }
            }
        } else {
            None
        };

        DiscoveryBehaviour {
            permanent_addresses,
            kademlia: kademlia_opt.into(),
            pending_events: VecDeque::new(),
            num_connections: 0,
            mdns: mdns_opt.into(),
            peers,
            peer_addresses,
        }
    }

    /// Returns reference to peer set.
    pub fn peers(&self) -> &HashSet<PeerId> {
        &self.peers
    }

    /// Returns a map of peer ids and their multiaddresses
    pub fn peer_addresses(&self) -> &HashMap<PeerId, Vec<Multiaddr>> {
        &self.peer_addresses
    }

    /// Bootstrap Kademlia network
    pub fn bootstrap(&mut self) -> Result<QueryId, String> {
        if let Some(active_kad) = self.kademlia.as_mut() {
            active_kad.bootstrap().map_err(|e| e.to_string())
        } else {
            Err("Kademlia is not activated".to_string())
        }
    }
}

impl NetworkBehaviour for DiscoveryBehaviour {
    type ConnectionHandler =
        ToggleConnectionHandler<<Kademlia<MemoryStore> as NetworkBehaviour>::ConnectionHandler>;
    type ToSwarm = DiscoveryOut;

    fn handle_established_inbound_connection(
        &mut self,
        connection_id: ConnectionId,
        peer: PeerId,
        local_addr: &Multiaddr,
        remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        self.kademlia.handle_established_inbound_connection(
            connection_id,
            peer,
            local_addr,
            remote_addr,
        )
    }

    fn handle_established_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        peer: PeerId,
        addr: &Multiaddr,
        role_override: Endpoint,
        port_use: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        self.kademlia.handle_established_outbound_connection(
            connection_id,
            peer,
            addr,
            role_override,
            port_use,
        )
    }

    fn handle_pending_inbound_connection(
        &mut self,
        connection_id: ConnectionId,
        local_addr: &Multiaddr,
        remote_addr: &Multiaddr,
    ) -> Result<(), ConnectionDenied> {
        self.kademlia
            .handle_pending_inbound_connection(connection_id, local_addr, remote_addr)
    }

    fn handle_pending_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        maybe_peer: Option<PeerId>,
        addresses: &[Multiaddr],
        effective_role: Endpoint,
    ) -> Result<Vec<Multiaddr>, ConnectionDenied> {
        let mut list = self
            .permanent_addresses
            .iter()
            .filter_map(|(p, a)| (*p == maybe_peer?).then(|| a.clone()))
            .collect::<Vec<_>>();

        if let Some(peer_id) = maybe_peer {
            let mut list_to_filter = self.kademlia.handle_pending_outbound_connection(
                connection_id,
                maybe_peer,
                addresses,
                effective_role,
            )?;

            list_to_filter.extend(self.mdns.handle_pending_outbound_connection(
                connection_id,
                maybe_peer,
                addresses,
                effective_role,
            )?);

            list.extend(list_to_filter);
        }

        trace!("Addresses of {:?}: {:?}", maybe_peer, list);
        Ok(list)
    }

    fn on_swarm_event(&mut self, event: FromSwarm) {
        match event {
            FromSwarm::ConnectionEstablished(ConnectionEstablished {
                peer_id,
                endpoint,
                connection_id,
                ..
            }) => {
                self.num_connections += 1;
                let multiaddrs: Vec<Multiaddr> = self
                    .permanent_addresses
                    .iter()
                    .filter(|(p, _)| *p == peer_id)
                    .map(|(_, a)| a.clone())
                    .collect();
                if !multiaddrs.is_empty() {
                    self.peer_addresses.insert(peer_id, multiaddrs.clone());
                }
                // Kademlia addresses are handled separately, we don't need to merge them here
                self.peers.insert(peer_id);
                println!(
                    "DiscoveryBehaviour: Added peer {} to peers set. Current peers count: {}",
                    peer_id,
                    self.peers.len()
                );
                self.pending_events
                    .push_back(DiscoveryOut::Connected(peer_id));
                // Forward the ConnectionEstablished event to kademlia
                // We need to reconstruct it from the received event
                // Forward the ConnectionEstablished event to kademlia
                // FromSwarm events can be forwarded directly
                self.kademlia
                    .on_swarm_event(FromSwarm::ConnectionEstablished(ConnectionEstablished {
                        peer_id,
                        endpoint: &endpoint,
                        connection_id,
                        failed_addresses: &[],
                        other_established: 0,
                    }));
            }
            FromSwarm::ConnectionClosed(ConnectionClosed {
                peer_id,
                connection_id,
                endpoint,
                remaining_established,
                cause,
            }) => {
                println!("DiscoveryBehaviour: ConnectionClosed for peer {}, remaining_established: {}, cause: {:?}", peer_id, remaining_established, cause);
                if remaining_established == 0 {
                    self.peers.remove(&peer_id);
                    self.peer_addresses.remove(&peer_id);
                    println!("DiscoveryBehaviour: Removed peer {} from peers set. Current peers count: {}", peer_id, self.peers.len());
                    self.pending_events
                        .push_back(DiscoveryOut::Disconnected(peer_id));
                } else {
                    println!("DiscoveryBehaviour: Connection closed but remaining_established > 0, keeping peer {} in set", peer_id);
                }
                self.num_connections -= 1;
                self.kademlia
                    .on_swarm_event(FromSwarm::ConnectionClosed(ConnectionClosed {
                        peer_id,
                        connection_id,
                        endpoint,
                        remaining_established,
                        cause,
                    }));
            }
            FromSwarm::DialFailure(e) => {
                self.kademlia.on_swarm_event(FromSwarm::DialFailure(e));
            }
            FromSwarm::ListenerClosed(e) => {
                self.kademlia.on_swarm_event(FromSwarm::ListenerClosed(e));
            }
            FromSwarm::ListenFailure(e) => {
                self.kademlia.on_swarm_event(FromSwarm::ListenFailure(e));
            }
            FromSwarm::ListenerError(e) => {
                self.kademlia.on_swarm_event(FromSwarm::ListenerError(e));
            }
            FromSwarm::ExternalAddrExpired(e) => {
                self.kademlia
                    .on_swarm_event(FromSwarm::ExternalAddrExpired(e));
            }
            FromSwarm::NewListener(e) => {
                self.kademlia.on_swarm_event(FromSwarm::NewListener(e));
            }
            FromSwarm::ExpiredListenAddr(e) => {
                self.kademlia
                    .on_swarm_event(FromSwarm::ExpiredListenAddr(e));
            }
            FromSwarm::NewExternalAddrCandidate(e) => {
                self.kademlia
                    .on_swarm_event(FromSwarm::NewExternalAddrCandidate(e));
            }
            FromSwarm::AddressChange(e) => {
                self.kademlia.on_swarm_event(FromSwarm::AddressChange(e));
            }
            FromSwarm::NewListenAddr(e) => {
                self.kademlia.on_swarm_event(FromSwarm::NewListenAddr(e));
                self.mdns.on_swarm_event(FromSwarm::NewListenAddr(e));
            }
            FromSwarm::ExternalAddrConfirmed(e) => {
                self.kademlia
                    .on_swarm_event(FromSwarm::ExternalAddrConfirmed(e));
            }
            FromSwarm::NewExternalAddrOfPeer(e) => {
                self.kademlia
                    .on_swarm_event(FromSwarm::NewExternalAddrOfPeer(e));
                self.mdns
                    .on_swarm_event(FromSwarm::NewExternalAddrOfPeer(e));
            }
            _ => {
                self.kademlia.on_swarm_event(event);
                self.mdns.on_swarm_event(event);
            }
        }
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        // Immediately process the content of `discovered`.
        if let Some(ev) = self.pending_events.pop_front() {
            return Poll::Ready(ToSwarm::GenerateEvent(ev));
        }

        // Poll Kademlia.
        loop {
            match self.kademlia.poll(cx) {
                Poll::Ready(ToSwarm::GenerateEvent(ev)) => match ev {
                    KademliaEvent::RoutingUpdated { .. } => {}
                    KademliaEvent::RoutablePeer { .. } => {}
                    KademliaEvent::PendingRoutablePeer { .. } => {}
                    other => {
                        debug!("Kademlia event: {:?}", other)
                    }
                },
                Poll::Ready(other) => {
                    // Convert ToSwarm<KademliaEvent, ...> to ToSwarm<DiscoveryOut, ...>
                    match other {
                        ToSwarm::Dial { opts } => {
                            return Poll::Ready(ToSwarm::Dial { opts });
                        }
                        ToSwarm::CloseConnection {
                            peer_id,
                            connection,
                        } => {
                            return Poll::Ready(ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            });
                        }
                        ToSwarm::NotifyHandler {
                            peer_id,
                            handler,
                            event: _,
                        } => {
                            // mdns doesn't have handler events, so this should not happen
                            // But we need to handle it to satisfy the type system
                            // mdns may generate NotifyHandler events in some cases
                            // Just ignore them and continue polling
                            continue;
                        }
                        // ReportObservedAddr is not a variant of ToSwarm in libp2p 0.54
                        // It's handled through other mechanisms
                        ToSwarm::GenerateEvent(_) => {
                            // This should have been handled above
                            unreachable!();
                        }
                        _ => {
                            // Handle any other ToSwarm variants
                            // We need to convert the event type
                            // Since mdns uses Void for HandlerIn, we can't use map_out
                            // Instead, we'll just return the event as-is and let the type system handle it
                            return Poll::Ready(
                                other
                                    .map_out(|_| {
                                        unreachable!("Kademlia should not generate other events")
                                    })
                                    .map_in(|_| {
                                        unreachable!("Kademlia should not generate handler events")
                                    }),
                            );
                        }
                    }
                }
                Poll::Pending => break,
            }
        }

        // Poll mdns.
        loop {
            match self.mdns.poll(cx) {
                Poll::Ready(ToSwarm::GenerateEvent(event)) => {
                    match event {
                        mdns::Event::Discovered(list) => {
                            // Add any discovered peers to Kademlia
                            for (peer_id, multiaddr) in list {
                                if let Some(kad) = self.kademlia.as_mut() {
                                    kad.add_address(&peer_id, multiaddr);
                                }
                            }
                        }
                        mdns::Event::Expired(_) => {}
                    }
                    // Continue polling
                }
                Poll::Ready(other) => {
                    // Convert ToSwarm<mdns::Event, ...> to ToSwarm<DiscoveryOut, ...>
                    match other {
                        ToSwarm::Dial { opts } => {
                            return Poll::Ready(ToSwarm::Dial { opts });
                        }
                        ToSwarm::CloseConnection {
                            peer_id,
                            connection,
                        } => {
                            return Poll::Ready(ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            });
                        }
                        ToSwarm::NotifyHandler {
                            peer_id,
                            handler,
                            event: _,
                        } => {
                            // mdns doesn't have handler events, so this should not happen
                            // But we need to handle it to satisfy the type system
                            // mdns may generate NotifyHandler events in some cases
                            // Just ignore them and continue polling
                            continue;
                        }
                        // ReportObservedAddr is not a variant of ToSwarm in libp2p 0.54
                        // It's handled through other mechanisms
                        ToSwarm::GenerateEvent(_) => {
                            // This should have been handled above
                            unreachable!();
                        }
                        _ => {
                            // Handle any other ToSwarm variants
                            // We need to convert the event type
                            // Since mdns uses Void for HandlerIn, we can't use map_out
                            // Instead, we'll just return the event as-is and let the type system handle it
                            return Poll::Ready(
                                other
                                    .map_out(|_| {
                                        unreachable!("Kademlia should not generate other events")
                                    })
                                    .map_in(|_| {
                                        unreachable!("Kademlia should not generate handler events")
                                    }),
                            );
                        }
                    }
                }
                Poll::Pending => break,
            }
        }

        // Poll pending events
        if let Some(ev) = self.pending_events.pop_front() {
            return Poll::Ready(ToSwarm::GenerateEvent(ev));
        }

        Poll::Pending
    }

    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: THandlerOutEvent<Self>,
    ) {
        if let Some(kad) = self.kademlia.as_mut() {
            kad.on_connection_handler_event(peer_id, connection_id, event);
        }
    }
}

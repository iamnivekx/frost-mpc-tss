use crate::Params;
use async_std::task;
use libp2p::identity::PublicKey;
use libp2p::kad::{store::MemoryStore, Behaviour as KademliaBehaviour, Config as KademliaConfig, Event as KademliaEvent, QueryId};
use libp2p::mdns::async_io::{Behaviour as MdnsBehaviour, Config as MdnsConfig};
use libp2p::swarm::behaviour::toggle::Toggle;
use libp2p::swarm::NetworkBehaviour;
use libp2p::{Multiaddr, PeerId};
use std::collections::VecDeque;
use tracing::warn;

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryEvent {
    /// Event that notifies that we connected to the node with the given peer id.
    Connected(PeerId),

    /// Event that notifies that we disconnected with the node with the given peer id.
    Disconnected(PeerId),
    Kademlia(KademliaEvent),
    Mdns(libp2p::mdns::Event),
}

#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "DiscoveryEvent")]
pub struct DiscoveryBehaviour {
    kademlia: Toggle<KademliaBehaviour<MemoryStore>>,
    mdns: Toggle<MdnsBehaviour>,
    #[behaviour(ignore)]
    _pending: VecDeque<DiscoveryEvent>,
}

impl From<KademliaEvent> for DiscoveryEvent {
    fn from(event: KademliaEvent) -> Self {
        DiscoveryEvent::Kademlia(event)
    }
}

impl From<libp2p::mdns::Event> for DiscoveryEvent {
    fn from(event: libp2p::mdns::Event) -> Self {
        DiscoveryEvent::Mdns(event)
    }
}

impl DiscoveryBehaviour {
    pub fn new(local_public_key: PublicKey, params: Params) -> Self {
        let local_peer_id = PeerId::from_public_key(&local_public_key);

        let permanent_addresses: Vec<_> = params
            .rooms
            .iter()
            .flat_map(|ra| ra.boot_nodes.clone())
            .map(|mwp| (mwp.peer_id, mwp.multiaddr))
            .collect();

        let kademlia_opt = {
            let store = MemoryStore::new(local_peer_id);
            let kad_config = KademliaConfig::default();

            if params.kademlia {
                let mut kademlia = KademliaBehaviour::with_config(local_peer_id, store, kad_config);
                for (peer_id, addr) in permanent_addresses.iter() {
                    kademlia.add_address(peer_id, addr.clone());
                }
                if let Err(e) = kademlia.bootstrap() {
                    warn!("Kademlia bootstrap failed: {}", e);
                }
                Some(kademlia)
            } else {
                None
            }
        };

        let mdns_opt = if params.mdns {
            Some(task::block_on(async {
                MdnsBehaviour::new(MdnsConfig::default())
                    .await
                    .expect("Could not start mDNS")
            }))
        } else {
            None
        };

        DiscoveryBehaviour {
            kademlia: kademlia_opt.into(),
            mdns: mdns_opt.into(),
            _pending: VecDeque::new(),
        }
    }

    /// Bootstrap Kademlia network
    pub fn bootstrap(&mut self) -> Result<QueryId, String> {
        if let Some(active_kad) = self.kademlia.as_mut() {
            active_kad.bootstrap().map_err(|e| e.to_string())
        } else {
            Err("Kademlia is not activated".to_string())
        }
    }

    pub fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        let mut addresses: Vec<Multiaddr> = Vec::new();
        if let Some(kad) = self.kademlia.as_mut() {
            addresses.extend(kad.addresses_of_peer(peer_id));
        }
        if let Some(mdns) = self.mdns.as_mut() {
            addresses.extend(mdns.addresses_of_peer(peer_id));
        }
        addresses
    }
}
